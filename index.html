<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>오목 AI 배틀 아레나</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 24px;
        }

        .game-setup {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .player-select {
            background: #f8f9fa;
            padding: 15px;
            min-width: 200px;
        }

        .player-select h3 {
            margin: 0 0 10px 0;
            color: #555;
        }

        select {
            width: 100%;
            padding: 8px;
            border: none;
            background: #f0f0f0;
            font-size: 14px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            margin: 0 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #status {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
        }

        canvas {
            background: #f5deb3;
            display: block;
            margin: 20px auto;
            border: 2px solid #333;
            border-radius: 10px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            min-width: 150px;
            text-align: center;
        }

        .stat-box h4 {
            margin: 0 0 5px 0;
            color: #666;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
        }

        .game-log {
            max-height: 150px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 10px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 5px;
        }

        .log-black { color: #333; }
        .log-white { color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>오목 AI 배틀 아레나</h1>

        <div class="game-setup">
            <div class="player-select">
                <h3>⚫ 흑돌 (선공)</h3>
                <select id="blackPlayer">
                    <option value="human" selected>사람</option>
                    <option value="2025">Omok 2025</option>
                    <option value="counter">Counter AI</option>
                </select>
            </div>

            <div class="player-select">
                <h3>⚪ 백돌 (후공)</h3>
                <select id="whitePlayer">
                    <option value="human">사람</option>
                    <option value="2025" selected>Omok 2025</option>
                    <option value="counter">Counter AI</option>
                </select>
            </div>

            <div class="player-select">
                <h3>⏱️ AI 속도</h3>
                <select id="aiSpeed">
                    <option value="0">즉시</option>
                    <option value="500" selected>빠름 (0.5초)</option>
                    <option value="1000">보통 (1초)</option>
                    <option value="2000">느림 (2초)</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">🎮 게임 시작</button>
            <button id="autoPlayBtn">🤖 AI 자동 대전</button>
            <button id="undoBtn">↩️ 한 수 무르기</button>
            <button id="resetBtn">🔄 초기화</button>
        </div>

        <div class="controls" style="margin-top: 10px;">
            <button id="firstMoveBtn" disabled>⏮️ 처음으로</button>
            <button id="prevMoveBtn" disabled>◀️ 이전 수</button>
            <button id="nextMoveBtn" disabled>▶️ 다음 수</button>
            <button id="lastMoveBtn" disabled>⏭️ 마지막으로</button>
            <button id="exitReviewBtn" disabled>❌ 리뷰 종료</button>
            <span id="moveInfo" style="margin-left: 20px; font-weight: bold;"></span>
        </div>

        <div id="status">게임을 시작하려면 설정을 선택하고 시작 버튼을 누르세요</div>

        <canvas id="board" width="600" height="600"></canvas>

        <div class="stats">
            <div class="stat-box">
                <h4>현재 턴</h4>
                <div id="turnCount" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <h4>흑돌 승리</h4>
                <div id="blackWins" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <h4>백돌 승리</h4>
                <div id="whiteWins" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <h4>총 게임 수</h4>
                <div id="totalGames" class="stat-value">0</div>
            </div>
        </div>

    </div>

    <script src="omok_2025.js"></script>
    <script src="omok_counter.js"></script>
    <script>
        // Game state
        const canvas = document.getElementById("board");
        const ctx = canvas.getContext("2d");
        const size = 15;
        const cellSize = canvas.width / size;
        let board = Array.from({length: size}, () => Array(size).fill(0));

        let currentPlayer = 1; // 1 = black, 2 = white
        let gameOver = false;
        let history = [];
        let lastMove = null;
        let autoPlay = false;
        let autoPlayTimeout = null; // 자동 대전 타임아웃 저장

        // Review mode variables
        let isReviewMode = false;
        let reviewIndex = 0;
        let savedHistory = [];
        let savedGameState = null;

        // AI instances
        const aiInstances = {
            2025: new Omok2025(size),
            counter: new OmokCounter(size)
        };

        // Statistics
        let stats = {
            blackWins: 0,
            whiteWins: 0,
            totalGames: 0,
            turnCount: 0
        };

        // UI Elements
        const statusDiv = document.getElementById("status");
        const blackPlayerSelect = document.getElementById("blackPlayer");
        const whitePlayerSelect = document.getElementById("whitePlayer");
        const aiSpeedSelect = document.getElementById("aiSpeed");
        const startBtn = document.getElementById("startBtn");
        const autoPlayBtn = document.getElementById("autoPlayBtn");
        const undoBtn = document.getElementById("undoBtn");
        const resetBtn = document.getElementById("resetBtn");
        const firstMoveBtn = document.getElementById("firstMoveBtn");
        const prevMoveBtn = document.getElementById("prevMoveBtn");
        const nextMoveBtn = document.getElementById("nextMoveBtn");
        const lastMoveBtn = document.getElementById("lastMoveBtn");
        const exitReviewBtn = document.getElementById("exitReviewBtn");
        const moveInfo = document.getElementById("moveInfo");

        // Drawing functions
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;

            // Draw grid
            for (let i = 0; i < size; i++) {
                ctx.beginPath();
                ctx.moveTo(cellSize/2, cellSize/2 + i*cellSize);
                ctx.lineTo(canvas.width - cellSize/2, cellSize/2 + i*cellSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(cellSize/2 + i*cellSize, cellSize/2);
                ctx.lineTo(cellSize/2 + i*cellSize, canvas.height - cellSize/2);
                ctx.stroke();
            }

            // Draw star points
            const starPoints = [[3, 3], [3, 11], [11, 3], [11, 11], [7, 7]];
            ctx.fillStyle = "#333";
            for (const [x, y] of starPoints) {
                ctx.beginPath();
                ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 3, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawStones() {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (board[y][x] !== 0) {
                        drawStone(x, y, board[y][x]);
                    }
                }
            }

            if (lastMove) {
                // Draw last move marker
                ctx.beginPath();
                ctx.arc(cellSize/2 + lastMove.x*cellSize, cellSize/2 + lastMove.y*cellSize, 5, 0, Math.PI*2);
                ctx.fillStyle = "red";
                ctx.fill();
            }
        }

        function drawStone(x, y, player) {
            const centerX = cellSize/2 + x*cellSize;
            const centerY = cellSize/2 + y*cellSize;

            // Draw shadow
            ctx.beginPath();
            ctx.arc(centerX + 2, centerY + 2, cellSize/2 - 3, 0, Math.PI*2);
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.fill();

            // Draw stone
            ctx.beginPath();
            ctx.arc(centerX, centerY, cellSize/2 - 3, 0, Math.PI*2);

            if (player === 1) {
                // Black stone with gradient
                const gradient = ctx.createRadialGradient(centerX - 5, centerY - 5, 0, centerX, centerY, cellSize/2);
                gradient.addColorStop(0, "#444");
                gradient.addColorStop(1, "#000");
                ctx.fillStyle = gradient;
            } else {
                // White stone with gradient
                const gradient = ctx.createRadialGradient(centerX - 5, centerY - 5, 0, centerX, centerY, cellSize/2);
                gradient.addColorStop(0, "#fff");
                gradient.addColorStop(1, "#ddd");
                ctx.fillStyle = gradient;
            }

            ctx.fill();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function checkWin(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];

            for (const [dx, dy] of directions) {
                let count = 1;

                // Count forward
                let nx = x + dx, ny = y + dy;
                while (nx >= 0 && ny >= 0 && nx < size && ny < size && board[ny][nx] === player) {
                    count++;
                    nx += dx;
                    ny += dy;
                }

                // Count backward
                nx = x - dx;
                ny = y - dy;
                while (nx >= 0 && ny >= 0 && nx < size && ny < size && board[ny][nx] === player) {
                    count++;
                    nx -= dx;
                    ny -= dy;
                }

                if (count >= 5) return true;
            }

            return false;
        }

        function addLog(message, className = "") {
            // 로그 비활성화
        }

        function updateStats() {
            document.getElementById("turnCount").textContent = stats.turnCount;
            document.getElementById("blackWins").textContent = stats.blackWins;
            document.getElementById("whiteWins").textContent = stats.whiteWins;
            document.getElementById("totalGames").textContent = stats.totalGames;
        }

        // 쌍삼 체크 함수
        function checkDoubleThree(x, y, player) {
            board[y][x] = player; // 임시로 놓기
            let count = 0;
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];

            for (const [dx, dy] of dirs) {
                let line = "";
                // 현재 위치를 중심으로 양방향 4칸씩 확인
                for (let k = -4; k <= 4; k++) {
                    let nx = x + k*dx, ny = y + k*dy;
                    if (nx < 0 || ny < 0 || nx >= size || ny >= size) {
                        line += "X"; // 범위 밖
                    } else if (board[ny][nx] === player) {
                        line += "O";
                    } else if (board[ny][nx] === 0) {
                        line += "_";
                    } else {
                        line += "X"; // 상대 돌
                    }
                }

                // 열린 3목 패턴 체크 (_OOO_)
                for (let i = 0; i <= line.length - 5; i++) {
                    if (line.substring(i, i+5) === "_OOO_") {
                        count++;
                    }
                }
            }

            board[y][x] = 0; // 되돌리기
            return count >= 2; // 2개 이상이면 쌍삼
        }

        function makeMove(x, y) {
            if (gameOver || board[y][x] !== 0) return false;

            // 사람이 둘 때만 쌍삼 체크
            const playerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
            if (playerType === "human" && checkDoubleThree(x, y, currentPlayer)) {
                alert("쌍삼 금지! 다른 위치에 두세요.");
                return false;
            }

            board[y][x] = currentPlayer;
            lastMove = {x, y, player: currentPlayer};
            history.push({x, y, player: currentPlayer});
            stats.turnCount++;

            const playerName = currentPlayer === 1 ? "흑돌" : "백돌";
            addLog(`${playerName} 착수: (${x}, ${y})`, currentPlayer === 1 ? "log-black" : "log-white");

            drawBoard();
            drawStones();
            updateStats();

            if (checkWin(x, y, currentPlayer)) {
                gameOver = true;
                const winner = currentPlayer === 1 ? "흑돌" : "백돌";
                statusDiv.textContent = `🎉 ${winner} 승리! 🎉`;
                addLog(`게임 종료: ${winner} 승리!`);

                if (currentPlayer === 1) {
                    stats.blackWins++;
                } else {
                    stats.whiteWins++;
                }
                stats.totalGames++;

                // 리뷰 모드 활성화
                enableReviewMode();

                if (autoPlay) {
                    // 자동 대전 모드일 때만 다음 게임 자동 시작
                    autoPlayTimeout = setTimeout(() => {
                        if (autoPlay) { // 다시 한번 체크 (사용자가 중간에 중지할 수 있음)
                            resetGame();
                            startGame();
                        }
                    }, 2000);
                }

                return true;
            }

            currentPlayer = 3 - currentPlayer;
            updateStatus();

            return true;
        }

        function updateStatus() {
            if (gameOver) return;

            const blackPlayer = blackPlayerSelect.value;
            const whitePlayer = whitePlayerSelect.value;

            let currentPlayerName = currentPlayer === 1 ? "흑돌" : "백돌";
            let currentPlayerType = currentPlayer === 1 ? blackPlayer : whitePlayer;

            if (currentPlayerType === "human") {
                statusDiv.textContent = `${currentPlayerName}(사람) 차례 - 클릭하여 착수하세요`;
            } else {
                statusDiv.textContent = `${currentPlayerName}(${currentPlayerType.toUpperCase()} AI) 생각 중...`;
            }
        }

        async function aiMove() {
            if (gameOver) return;

            const playerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
            if (playerType === "human") return;

            const ai = aiInstances[playerType];
            const boardCopy = board.map(row => [...row]);

            // Get AI move
            const startTime = Date.now();
            const move = ai.getMove(boardCopy, currentPlayer);
            const thinkTime = Date.now() - startTime;

            if (move && !gameOver) {
                addLog(`${playerType.toUpperCase()} AI 계산 시간: ${thinkTime}ms`);

                const aiSpeed = parseInt(aiSpeedSelect.value);
                if (aiSpeed > 0) {
                    await new Promise(resolve => setTimeout(resolve, Math.max(0, aiSpeed - thinkTime)));
                }

                makeMove(move.x, move.y);

                // Continue if next player is also AI
                const nextPlayerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
                if (nextPlayerType !== "human" && !gameOver) {
                    setTimeout(aiMove, 100);
                }
            }
        }

        function resetGame() {
            // Clear board
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    board[y][x] = 0;
                }
            }

            currentPlayer = 1;
            gameOver = true; // 게임이 시작되지 않은 상태로 설정
            history = [];
            lastMove = null;

            // Reset review mode
            isReviewMode = false;
            reviewIndex = 0;
            savedHistory = [];
            savedGameState = null;
            firstMoveBtn.disabled = true;
            prevMoveBtn.disabled = true;
            nextMoveBtn.disabled = true;
            lastMoveBtn.disabled = true;
            exitReviewBtn.disabled = true;
            moveInfo.textContent = "";
            stats.turnCount = 0;

            drawBoard();
            drawStones();
            updateStats();

            statusDiv.textContent = "게임이 초기화되었습니다";
            addLog("게임 초기화");
        }

        function exitReviewMode() {
            if (!isReviewMode) return;

            isReviewMode = false;

            // Restore the saved game state
            if (savedGameState) {
                board = savedGameState.board.map(row => [...row]);
                currentPlayer = savedGameState.currentPlayer;
                gameOver = savedGameState.gameOver;
            }

            // Restore history
            history = [...savedHistory];
            lastMove = history.length > 0 ? history[history.length - 1] : null;

            // Disable review buttons
            firstMoveBtn.disabled = true;
            prevMoveBtn.disabled = true;
            nextMoveBtn.disabled = true;
            lastMoveBtn.disabled = true;
            exitReviewBtn.disabled = true;
            moveInfo.textContent = "";

            drawBoard();
            drawStones();
            updateStatus();

            addLog("리뷰 모드 종료");
        }

        function startGame() {
            // Exit review mode if active
            exitReviewMode();

            // 항상 초기화하고 시작
            resetGame();

            gameOver = false;

            const blackPlayer = blackPlayerSelect.value;
            const whitePlayer = whitePlayerSelect.value;

            addLog(`새 게임 시작: 흑(${blackPlayer}) vs 백(${whitePlayer})`);
            updateStatus();

            // Start AI if first player is AI
            if (blackPlayer !== "human") {
                setTimeout(aiMove, 500);
            }
        }

        // Event handlers
        canvas.addEventListener("click", (e) => {
            // 리뷰 모드에서는 클릭 이벤트 무시
            if (isReviewMode) return;

            if (gameOver) return;

            const playerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
            if (playerType !== "human") return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left - cellSize/2) / cellSize);
            const y = Math.round((e.clientY - rect.top - cellSize/2) / cellSize);

            if (x >= 0 && x < size && y >= 0 && y < size) {
                if (makeMove(x, y)) {
                    // Check if next player is AI
                    const nextPlayerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
                    if (nextPlayerType !== "human") {
                        setTimeout(aiMove, 100);
                    }
                }
            }
        });

        startBtn.addEventListener("click", startGame);

        autoPlayBtn.addEventListener("click", () => {
            autoPlay = !autoPlay;
            autoPlayBtn.textContent = autoPlay ? "🛑 자동 대전 중지" : "🤖 AI 자동 대전";

            if (autoPlay) {
                addLog("AI 자동 대전 모드 시작");
                // 게임이 진행중이 아니면 새 게임 시작
                if (gameOver || !history.length) {
                    startGame();
                }
            } else {
                addLog("AI 자동 대전 모드 종료");
            }
        });

        undoBtn.addEventListener("click", () => {
            // 리뷰 모드에서는 무르기 비활성화
            if (isReviewMode) return;

            if (history.length === 0) return;

            // 두 수를 무르기 (내 수와 상대 수)
            let movesToUndo = [];

            // 마지막 수 (상대방 수) 무르기
            if (history.length > 0) {
                const lastMove = history.pop();
                board[lastMove.y][lastMove.x] = 0;
                movesToUndo.push(lastMove);
                stats.turnCount--;
            }

            // 그 이전 수 (내 수) 무르기
            if (history.length > 0) {
                const myMove = history.pop();
                board[myMove.y][myMove.x] = 0;
                movesToUndo.push(myMove);
                stats.turnCount--;
            }

            // 현재 플레이어는 변경하지 않음 (내 차례로 유지)
            lastMove = history.length > 0 ? history[history.length - 1] : null;

            // 게임이 끝난 상태였다면 게임을 재개
            if (gameOver) {
                gameOver = false;
            }

            drawBoard();
            drawStones();
            updateStats();
            updateStatus();

            if (movesToUndo.length > 0) {
                addLog(`한 수 무르기: ${movesToUndo.map(m => `(${m.x}, ${m.y})`).join(', ')}`);
            }
        });

        resetBtn.addEventListener("click", () => {
            // 자동 대전 타이머 취소
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
                autoPlayTimeout = null;
            }

            // 자동 대전 중지
            if (autoPlay) {
                autoPlay = false;
                autoPlayBtn.textContent = "🤖 AI 자동 대전";
            }

            // 게임 초기화
            resetGame();

            // 초기 상태로 완전 복원
            gameOver = true; // 게임이 시작되지 않은 상태로 설정
            statusDiv.textContent = "게임을 시작하려면 설정을 선택하고 시작 버튼을 누르세요";
        });

        // Review Mode Functions
        function enableReviewMode() {
            isReviewMode = true;
            savedHistory = [...history];

            savedGameState = {
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                gameOver: gameOver
            };
            reviewIndex = savedHistory.length;

            // Enable review buttons
            firstMoveBtn.disabled = false;
            prevMoveBtn.disabled = false;
            nextMoveBtn.disabled = false;
            lastMoveBtn.disabled = false;
            exitReviewBtn.disabled = false;

            updateReviewInfo();
            addLog("리뷰 모드가 활성화되었습니다. 버튼을 사용해 기보를 재생할 수 있습니다.");
        }

        function updateReviewInfo() {
            if (isReviewMode) {
                moveInfo.textContent = `수: ${reviewIndex} / ${savedHistory.length}`;

                // Update button states
                firstMoveBtn.disabled = reviewIndex === 0;
                prevMoveBtn.disabled = reviewIndex === 0;
                nextMoveBtn.disabled = reviewIndex === savedHistory.length;
                lastMoveBtn.disabled = reviewIndex === savedHistory.length;
            }
        }

        function reconstructBoard(upToIndex) {
            // Clear board
            board = Array(size).fill(null).map(() => Array(size).fill(0));

            // Replay moves up to the index
            for (let i = 0; i < upToIndex; i++) {
                const move = savedHistory[i];
                if (!move) {
                    continue;
                }
                board[move.y][move.x] = move.player;
            }

            // Set lastMove for highlighting
            lastMove = upToIndex > 0 ? savedHistory[upToIndex - 1] : null;

            // Redraw
            drawBoard();
            drawStones();
            updateReviewInfo();
        }

        // Review Mode Event Handlers
        firstMoveBtn.addEventListener("click", () => {
            if (!isReviewMode) return;
            reviewIndex = 0;
            reconstructBoard(reviewIndex);
            addLog("처음으로 이동");
        });

        prevMoveBtn.addEventListener("click", () => {
            if (!isReviewMode || reviewIndex === 0) return;
            reviewIndex--;
            reconstructBoard(reviewIndex);
            addLog(`이전 수로 이동: ${reviewIndex}수`);
        });

        nextMoveBtn.addEventListener("click", () => { 
            if (!isReviewMode || reviewIndex === savedHistory.length) return;
            reviewIndex++;
            reconstructBoard(reviewIndex);
            addLog(`다음 수로 이동: ${reviewIndex}수`);
        });

        lastMoveBtn.addEventListener("click", () => {
            if (!isReviewMode) return;
            reviewIndex = savedHistory.length;
            reconstructBoard(reviewIndex);
            addLog("마지막으로 이동");
        });

        exitReviewBtn.addEventListener("click", () => {
            if (!isReviewMode) return;
            exitReviewMode();
        });

        // Initialize
        drawBoard();
        updateStats();
    </script>
</body>
</html>
