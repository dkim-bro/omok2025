<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ì˜¤ëª© AI ë°°í‹€ ì•„ë ˆë‚˜</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 24px;
        }

        .game-setup {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .player-select {
            background: #f8f9fa;
            padding: 15px;
            min-width: 200px;
        }

        .player-select h3 {
            margin: 0 0 10px 0;
            color: #555;
        }

        select {
            width: 100%;
            padding: 8px;
            border: none;
            background: #f0f0f0;
            font-size: 14px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            margin: 0 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #status {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
        }

        canvas {
            background: #f5deb3;
            display: block;
            margin: 20px auto;
            border: 2px solid #333;
            border-radius: 10px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            min-width: 150px;
            text-align: center;
        }

        .stat-box h4 {
            margin: 0 0 5px 0;
            color: #666;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
        }

        .game-log {
            max-height: 150px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 10px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 5px;
        }

        .log-black { color: #333; }
        .log-white { color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ì˜¤ëª© AI ë°°í‹€ ì•„ë ˆë‚˜</h1>

        <div class="game-setup">
            <div class="player-select">
                <h3>âš« í‘ëŒ (ì„ ê³µ)</h3>
                <select id="blackPlayer">
                    <option value="human" selected>ì‚¬ëŒ</option>
                    <option value="2025">Omok 2025</option>
                    <option value="counter">Counter AI</option>
                </select>
            </div>

            <div class="player-select">
                <h3>âšª ë°±ëŒ (í›„ê³µ)</h3>
                <select id="whitePlayer">
                    <option value="human">ì‚¬ëŒ</option>
                    <option value="2025" selected>Omok 2025</option>
                    <option value="counter">Counter AI</option>
                </select>
            </div>

            <div class="player-select">
                <h3>â±ï¸ AI ì†ë„</h3>
                <select id="aiSpeed">
                    <option value="0">ì¦‰ì‹œ</option>
                    <option value="500" selected>ë¹ ë¦„ (0.5ì´ˆ)</option>
                    <option value="1000">ë³´í†µ (1ì´ˆ)</option>
                    <option value="2000">ëŠë¦¼ (2ì´ˆ)</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">ğŸ® ê²Œì„ ì‹œì‘</button>
            <button id="autoPlayBtn">ğŸ¤– AI ìë™ ëŒ€ì „</button>
            <button id="undoBtn">â†©ï¸ í•œ ìˆ˜ ë¬´ë¥´ê¸°</button>
            <button id="resetBtn">ğŸ”„ ì´ˆê¸°í™”</button>
        </div>

        <div class="controls" style="margin-top: 10px;">
            <button id="firstMoveBtn" disabled>â®ï¸ ì²˜ìŒìœ¼ë¡œ</button>
            <button id="prevMoveBtn" disabled>â—€ï¸ ì´ì „ ìˆ˜</button>
            <button id="nextMoveBtn" disabled>â–¶ï¸ ë‹¤ìŒ ìˆ˜</button>
            <button id="lastMoveBtn" disabled>â­ï¸ ë§ˆì§€ë§‰ìœ¼ë¡œ</button>
            <button id="exitReviewBtn" disabled>âŒ ë¦¬ë·° ì¢…ë£Œ</button>
            <span id="moveInfo" style="margin-left: 20px; font-weight: bold;"></span>
        </div>

        <div id="status">ê²Œì„ì„ ì‹œì‘í•˜ë ¤ë©´ ì„¤ì •ì„ ì„ íƒí•˜ê³  ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”</div>

        <canvas id="board" width="600" height="600"></canvas>

        <div class="stats">
            <div class="stat-box">
                <h4>í˜„ì¬ í„´</h4>
                <div id="turnCount" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <h4>í‘ëŒ ìŠ¹ë¦¬</h4>
                <div id="blackWins" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <h4>ë°±ëŒ ìŠ¹ë¦¬</h4>
                <div id="whiteWins" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <h4>ì´ ê²Œì„ ìˆ˜</h4>
                <div id="totalGames" class="stat-value">0</div>
            </div>
        </div>

    </div>

    <script src="omok_2025.js"></script>
    <script src="omok_counter.js"></script>
    <script>
        // Game state
        const canvas = document.getElementById("board");
        const ctx = canvas.getContext("2d");
        const size = 15;
        const cellSize = canvas.width / size;
        let board = Array.from({length: size}, () => Array(size).fill(0));

        let currentPlayer = 1; // 1 = black, 2 = white
        let gameOver = false;
        let history = [];
        let lastMove = null;
        let autoPlay = false;
        let autoPlayTimeout = null; // ìë™ ëŒ€ì „ íƒ€ì„ì•„ì›ƒ ì €ì¥

        // Review mode variables
        let isReviewMode = false;
        let reviewIndex = 0;
        let savedHistory = [];
        let savedGameState = null;

        // AI instances
        const aiInstances = {
            2025: new Omok2025(size),
            counter: new OmokCounter(size)
        };

        // Statistics
        let stats = {
            blackWins: 0,
            whiteWins: 0,
            totalGames: 0,
            turnCount: 0
        };

        // UI Elements
        const statusDiv = document.getElementById("status");
        const blackPlayerSelect = document.getElementById("blackPlayer");
        const whitePlayerSelect = document.getElementById("whitePlayer");
        const aiSpeedSelect = document.getElementById("aiSpeed");
        const startBtn = document.getElementById("startBtn");
        const autoPlayBtn = document.getElementById("autoPlayBtn");
        const undoBtn = document.getElementById("undoBtn");
        const resetBtn = document.getElementById("resetBtn");
        const firstMoveBtn = document.getElementById("firstMoveBtn");
        const prevMoveBtn = document.getElementById("prevMoveBtn");
        const nextMoveBtn = document.getElementById("nextMoveBtn");
        const lastMoveBtn = document.getElementById("lastMoveBtn");
        const exitReviewBtn = document.getElementById("exitReviewBtn");
        const moveInfo = document.getElementById("moveInfo");

        // Drawing functions
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;

            // Draw grid
            for (let i = 0; i < size; i++) {
                ctx.beginPath();
                ctx.moveTo(cellSize/2, cellSize/2 + i*cellSize);
                ctx.lineTo(canvas.width - cellSize/2, cellSize/2 + i*cellSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(cellSize/2 + i*cellSize, cellSize/2);
                ctx.lineTo(cellSize/2 + i*cellSize, canvas.height - cellSize/2);
                ctx.stroke();
            }

            // Draw star points
            const starPoints = [[3, 3], [3, 11], [11, 3], [11, 11], [7, 7]];
            ctx.fillStyle = "#333";
            for (const [x, y] of starPoints) {
                ctx.beginPath();
                ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 3, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawStones() {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (board[y][x] !== 0) {
                        drawStone(x, y, board[y][x]);
                    }
                }
            }

            if (lastMove) {
                // Draw last move marker
                ctx.beginPath();
                ctx.arc(cellSize/2 + lastMove.x*cellSize, cellSize/2 + lastMove.y*cellSize, 5, 0, Math.PI*2);
                ctx.fillStyle = "red";
                ctx.fill();
            }
        }

        function drawStone(x, y, player) {
            const centerX = cellSize/2 + x*cellSize;
            const centerY = cellSize/2 + y*cellSize;

            // Draw shadow
            ctx.beginPath();
            ctx.arc(centerX + 2, centerY + 2, cellSize/2 - 3, 0, Math.PI*2);
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.fill();

            // Draw stone
            ctx.beginPath();
            ctx.arc(centerX, centerY, cellSize/2 - 3, 0, Math.PI*2);

            if (player === 1) {
                // Black stone with gradient
                const gradient = ctx.createRadialGradient(centerX - 5, centerY - 5, 0, centerX, centerY, cellSize/2);
                gradient.addColorStop(0, "#444");
                gradient.addColorStop(1, "#000");
                ctx.fillStyle = gradient;
            } else {
                // White stone with gradient
                const gradient = ctx.createRadialGradient(centerX - 5, centerY - 5, 0, centerX, centerY, cellSize/2);
                gradient.addColorStop(0, "#fff");
                gradient.addColorStop(1, "#ddd");
                ctx.fillStyle = gradient;
            }

            ctx.fill();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function checkWin(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];

            for (const [dx, dy] of directions) {
                let count = 1;

                // Count forward
                let nx = x + dx, ny = y + dy;
                while (nx >= 0 && ny >= 0 && nx < size && ny < size && board[ny][nx] === player) {
                    count++;
                    nx += dx;
                    ny += dy;
                }

                // Count backward
                nx = x - dx;
                ny = y - dy;
                while (nx >= 0 && ny >= 0 && nx < size && ny < size && board[ny][nx] === player) {
                    count++;
                    nx -= dx;
                    ny -= dy;
                }

                if (count >= 5) return true;
            }

            return false;
        }

        function addLog(message, className = "") {
            // ë¡œê·¸ ë¹„í™œì„±í™”
        }

        function updateStats() {
            document.getElementById("turnCount").textContent = stats.turnCount;
            document.getElementById("blackWins").textContent = stats.blackWins;
            document.getElementById("whiteWins").textContent = stats.whiteWins;
            document.getElementById("totalGames").textContent = stats.totalGames;
        }

        // ìŒì‚¼ ì²´í¬ í•¨ìˆ˜
        function checkDoubleThree(x, y, player) {
            board[y][x] = player; // ì„ì‹œë¡œ ë†“ê¸°
            let count = 0;
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];

            for (const [dx, dy] of dirs) {
                let line = "";
                // í˜„ì¬ ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì–‘ë°©í–¥ 4ì¹¸ì”© í™•ì¸
                for (let k = -4; k <= 4; k++) {
                    let nx = x + k*dx, ny = y + k*dy;
                    if (nx < 0 || ny < 0 || nx >= size || ny >= size) {
                        line += "X"; // ë²”ìœ„ ë°–
                    } else if (board[ny][nx] === player) {
                        line += "O";
                    } else if (board[ny][nx] === 0) {
                        line += "_";
                    } else {
                        line += "X"; // ìƒëŒ€ ëŒ
                    }
                }

                // ì—´ë¦° 3ëª© íŒ¨í„´ ì²´í¬ (_OOO_)
                for (let i = 0; i <= line.length - 5; i++) {
                    if (line.substring(i, i+5) === "_OOO_") {
                        count++;
                    }
                }
            }

            board[y][x] = 0; // ë˜ëŒë¦¬ê¸°
            return count >= 2; // 2ê°œ ì´ìƒì´ë©´ ìŒì‚¼
        }

        function makeMove(x, y) {
            if (gameOver || board[y][x] !== 0) return false;

            // ì‚¬ëŒì´ ë‘˜ ë•Œë§Œ ìŒì‚¼ ì²´í¬
            const playerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
            if (playerType === "human" && checkDoubleThree(x, y, currentPlayer)) {
                alert("ìŒì‚¼ ê¸ˆì§€! ë‹¤ë¥¸ ìœ„ì¹˜ì— ë‘ì„¸ìš”.");
                return false;
            }

            board[y][x] = currentPlayer;
            lastMove = {x, y, player: currentPlayer};
            history.push({x, y, player: currentPlayer});
            stats.turnCount++;

            const playerName = currentPlayer === 1 ? "í‘ëŒ" : "ë°±ëŒ";
            addLog(`${playerName} ì°©ìˆ˜: (${x}, ${y})`, currentPlayer === 1 ? "log-black" : "log-white");

            drawBoard();
            drawStones();
            updateStats();

            if (checkWin(x, y, currentPlayer)) {
                gameOver = true;
                const winner = currentPlayer === 1 ? "í‘ëŒ" : "ë°±ëŒ";
                statusDiv.textContent = `ğŸ‰ ${winner} ìŠ¹ë¦¬! ğŸ‰`;
                addLog(`ê²Œì„ ì¢…ë£Œ: ${winner} ìŠ¹ë¦¬!`);

                if (currentPlayer === 1) {
                    stats.blackWins++;
                } else {
                    stats.whiteWins++;
                }
                stats.totalGames++;

                // ë¦¬ë·° ëª¨ë“œ í™œì„±í™”
                enableReviewMode();

                if (autoPlay) {
                    // ìë™ ëŒ€ì „ ëª¨ë“œì¼ ë•Œë§Œ ë‹¤ìŒ ê²Œì„ ìë™ ì‹œì‘
                    autoPlayTimeout = setTimeout(() => {
                        if (autoPlay) { // ë‹¤ì‹œ í•œë²ˆ ì²´í¬ (ì‚¬ìš©ìê°€ ì¤‘ê°„ì— ì¤‘ì§€í•  ìˆ˜ ìˆìŒ)
                            resetGame();
                            startGame();
                        }
                    }, 2000);
                }

                return true;
            }

            currentPlayer = 3 - currentPlayer;
            updateStatus();

            return true;
        }

        function updateStatus() {
            if (gameOver) return;

            const blackPlayer = blackPlayerSelect.value;
            const whitePlayer = whitePlayerSelect.value;

            let currentPlayerName = currentPlayer === 1 ? "í‘ëŒ" : "ë°±ëŒ";
            let currentPlayerType = currentPlayer === 1 ? blackPlayer : whitePlayer;

            if (currentPlayerType === "human") {
                statusDiv.textContent = `${currentPlayerName}(ì‚¬ëŒ) ì°¨ë¡€ - í´ë¦­í•˜ì—¬ ì°©ìˆ˜í•˜ì„¸ìš”`;
            } else {
                statusDiv.textContent = `${currentPlayerName}(${currentPlayerType.toUpperCase()} AI) ìƒê° ì¤‘...`;
            }
        }

        async function aiMove() {
            if (gameOver) return;

            const playerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
            if (playerType === "human") return;

            const ai = aiInstances[playerType];
            const boardCopy = board.map(row => [...row]);

            // Get AI move
            const startTime = Date.now();
            const move = ai.getMove(boardCopy, currentPlayer);
            const thinkTime = Date.now() - startTime;

            if (move && !gameOver) {
                addLog(`${playerType.toUpperCase()} AI ê³„ì‚° ì‹œê°„: ${thinkTime}ms`);

                const aiSpeed = parseInt(aiSpeedSelect.value);
                if (aiSpeed > 0) {
                    await new Promise(resolve => setTimeout(resolve, Math.max(0, aiSpeed - thinkTime)));
                }

                makeMove(move.x, move.y);

                // Continue if next player is also AI
                const nextPlayerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
                if (nextPlayerType !== "human" && !gameOver) {
                    setTimeout(aiMove, 100);
                }
            }
        }

        function resetGame() {
            // Clear board
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    board[y][x] = 0;
                }
            }

            currentPlayer = 1;
            gameOver = true; // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì„¤ì •
            history = [];
            lastMove = null;

            // Reset review mode
            isReviewMode = false;
            reviewIndex = 0;
            savedHistory = [];
            savedGameState = null;
            firstMoveBtn.disabled = true;
            prevMoveBtn.disabled = true;
            nextMoveBtn.disabled = true;
            lastMoveBtn.disabled = true;
            exitReviewBtn.disabled = true;
            moveInfo.textContent = "";
            stats.turnCount = 0;

            drawBoard();
            drawStones();
            updateStats();

            statusDiv.textContent = "ê²Œì„ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤";
            addLog("ê²Œì„ ì´ˆê¸°í™”");
        }

        function exitReviewMode() {
            if (!isReviewMode) return;

            isReviewMode = false;

            // Restore the saved game state
            if (savedGameState) {
                board = savedGameState.board.map(row => [...row]);
                currentPlayer = savedGameState.currentPlayer;
                gameOver = savedGameState.gameOver;
            }

            // Restore history
            history = [...savedHistory];
            lastMove = history.length > 0 ? history[history.length - 1] : null;

            // Disable review buttons
            firstMoveBtn.disabled = true;
            prevMoveBtn.disabled = true;
            nextMoveBtn.disabled = true;
            lastMoveBtn.disabled = true;
            exitReviewBtn.disabled = true;
            moveInfo.textContent = "";

            drawBoard();
            drawStones();
            updateStatus();

            addLog("ë¦¬ë·° ëª¨ë“œ ì¢…ë£Œ");
        }

        function startGame() {
            // Exit review mode if active
            exitReviewMode();

            // í•­ìƒ ì´ˆê¸°í™”í•˜ê³  ì‹œì‘
            resetGame();

            gameOver = false;

            const blackPlayer = blackPlayerSelect.value;
            const whitePlayer = whitePlayerSelect.value;

            addLog(`ìƒˆ ê²Œì„ ì‹œì‘: í‘(${blackPlayer}) vs ë°±(${whitePlayer})`);
            updateStatus();

            // Start AI if first player is AI
            if (blackPlayer !== "human") {
                setTimeout(aiMove, 500);
            }
        }

        // Event handlers
        canvas.addEventListener("click", (e) => {
            // ë¦¬ë·° ëª¨ë“œì—ì„œëŠ” í´ë¦­ ì´ë²¤íŠ¸ ë¬´ì‹œ
            if (isReviewMode) return;

            if (gameOver) return;

            const playerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
            if (playerType !== "human") return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left - cellSize/2) / cellSize);
            const y = Math.round((e.clientY - rect.top - cellSize/2) / cellSize);

            if (x >= 0 && x < size && y >= 0 && y < size) {
                if (makeMove(x, y)) {
                    // Check if next player is AI
                    const nextPlayerType = currentPlayer === 1 ? blackPlayerSelect.value : whitePlayerSelect.value;
                    if (nextPlayerType !== "human") {
                        setTimeout(aiMove, 100);
                    }
                }
            }
        });

        startBtn.addEventListener("click", startGame);

        autoPlayBtn.addEventListener("click", () => {
            autoPlay = !autoPlay;
            autoPlayBtn.textContent = autoPlay ? "ğŸ›‘ ìë™ ëŒ€ì „ ì¤‘ì§€" : "ğŸ¤– AI ìë™ ëŒ€ì „";

            if (autoPlay) {
                addLog("AI ìë™ ëŒ€ì „ ëª¨ë“œ ì‹œì‘");
                // ê²Œì„ì´ ì§„í–‰ì¤‘ì´ ì•„ë‹ˆë©´ ìƒˆ ê²Œì„ ì‹œì‘
                if (gameOver || !history.length) {
                    startGame();
                }
            } else {
                addLog("AI ìë™ ëŒ€ì „ ëª¨ë“œ ì¢…ë£Œ");
            }
        });

        undoBtn.addEventListener("click", () => {
            // ë¦¬ë·° ëª¨ë“œì—ì„œëŠ” ë¬´ë¥´ê¸° ë¹„í™œì„±í™”
            if (isReviewMode) return;

            if (history.length === 0) return;

            // ë‘ ìˆ˜ë¥¼ ë¬´ë¥´ê¸° (ë‚´ ìˆ˜ì™€ ìƒëŒ€ ìˆ˜)
            let movesToUndo = [];

            // ë§ˆì§€ë§‰ ìˆ˜ (ìƒëŒ€ë°© ìˆ˜) ë¬´ë¥´ê¸°
            if (history.length > 0) {
                const lastMove = history.pop();
                board[lastMove.y][lastMove.x] = 0;
                movesToUndo.push(lastMove);
                stats.turnCount--;
            }

            // ê·¸ ì´ì „ ìˆ˜ (ë‚´ ìˆ˜) ë¬´ë¥´ê¸°
            if (history.length > 0) {
                const myMove = history.pop();
                board[myMove.y][myMove.x] = 0;
                movesToUndo.push(myMove);
                stats.turnCount--;
            }

            // í˜„ì¬ í”Œë ˆì´ì–´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ (ë‚´ ì°¨ë¡€ë¡œ ìœ ì§€)
            lastMove = history.length > 0 ? history[history.length - 1] : null;

            // ê²Œì„ì´ ëë‚œ ìƒíƒœì˜€ë‹¤ë©´ ê²Œì„ì„ ì¬ê°œ
            if (gameOver) {
                gameOver = false;
            }

            drawBoard();
            drawStones();
            updateStats();
            updateStatus();

            if (movesToUndo.length > 0) {
                addLog(`í•œ ìˆ˜ ë¬´ë¥´ê¸°: ${movesToUndo.map(m => `(${m.x}, ${m.y})`).join(', ')}`);
            }
        });

        resetBtn.addEventListener("click", () => {
            // ìë™ ëŒ€ì „ íƒ€ì´ë¨¸ ì·¨ì†Œ
            if (autoPlayTimeout) {
                clearTimeout(autoPlayTimeout);
                autoPlayTimeout = null;
            }

            // ìë™ ëŒ€ì „ ì¤‘ì§€
            if (autoPlay) {
                autoPlay = false;
                autoPlayBtn.textContent = "ğŸ¤– AI ìë™ ëŒ€ì „";
            }

            // ê²Œì„ ì´ˆê¸°í™”
            resetGame();

            // ì´ˆê¸° ìƒíƒœë¡œ ì™„ì „ ë³µì›
            gameOver = true; // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì„¤ì •
            statusDiv.textContent = "ê²Œì„ì„ ì‹œì‘í•˜ë ¤ë©´ ì„¤ì •ì„ ì„ íƒí•˜ê³  ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”";
        });

        // Review Mode Functions
        function enableReviewMode() {
            isReviewMode = true;
            savedHistory = [...history];

            savedGameState = {
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                gameOver: gameOver
            };
            reviewIndex = savedHistory.length;

            // Enable review buttons
            firstMoveBtn.disabled = false;
            prevMoveBtn.disabled = false;
            nextMoveBtn.disabled = false;
            lastMoveBtn.disabled = false;
            exitReviewBtn.disabled = false;

            updateReviewInfo();
            addLog("ë¦¬ë·° ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë²„íŠ¼ì„ ì‚¬ìš©í•´ ê¸°ë³´ë¥¼ ì¬ìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
        }

        function updateReviewInfo() {
            if (isReviewMode) {
                moveInfo.textContent = `ìˆ˜: ${reviewIndex} / ${savedHistory.length}`;

                // Update button states
                firstMoveBtn.disabled = reviewIndex === 0;
                prevMoveBtn.disabled = reviewIndex === 0;
                nextMoveBtn.disabled = reviewIndex === savedHistory.length;
                lastMoveBtn.disabled = reviewIndex === savedHistory.length;
            }
        }

        function reconstructBoard(upToIndex) {
            // Clear board
            board = Array(size).fill(null).map(() => Array(size).fill(0));

            // Replay moves up to the index
            for (let i = 0; i < upToIndex; i++) {
                const move = savedHistory[i];
                if (!move) {
                    continue;
                }
                board[move.y][move.x] = move.player;
            }

            // Set lastMove for highlighting
            lastMove = upToIndex > 0 ? savedHistory[upToIndex - 1] : null;

            // Redraw
            drawBoard();
            drawStones();
            updateReviewInfo();
        }

        // Review Mode Event Handlers
        firstMoveBtn.addEventListener("click", () => {
            if (!isReviewMode) return;
            reviewIndex = 0;
            reconstructBoard(reviewIndex);
            addLog("ì²˜ìŒìœ¼ë¡œ ì´ë™");
        });

        prevMoveBtn.addEventListener("click", () => {
            if (!isReviewMode || reviewIndex === 0) return;
            reviewIndex--;
            reconstructBoard(reviewIndex);
            addLog(`ì´ì „ ìˆ˜ë¡œ ì´ë™: ${reviewIndex}ìˆ˜`);
        });

        nextMoveBtn.addEventListener("click", () => { 
            if (!isReviewMode || reviewIndex === savedHistory.length) return;
            reviewIndex++;
            reconstructBoard(reviewIndex);
            addLog(`ë‹¤ìŒ ìˆ˜ë¡œ ì´ë™: ${reviewIndex}ìˆ˜`);
        });

        lastMoveBtn.addEventListener("click", () => {
            if (!isReviewMode) return;
            reviewIndex = savedHistory.length;
            reconstructBoard(reviewIndex);
            addLog("ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™");
        });

        exitReviewBtn.addEventListener("click", () => {
            if (!isReviewMode) return;
            exitReviewMode();
        });

        // Initialize
        drawBoard();
        updateStats();
    </script>
</body>
</html>
